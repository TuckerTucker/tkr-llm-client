# Code Quality Standards Fragment
# Reusable code quality evaluation guidelines
# Demonstrates: Prompt fragment for quality assessment criteria

fragment:
  name: code-quality

  instructions: |
    ## Code Quality Assessment Framework

    ### 1. Readability and Clarity
    - **Naming conventions**: Variables, functions, classes use descriptive, meaningful names
    - **Code organization**: Logical structure with clear separation of concerns
    - **Complexity management**: Functions are focused and do one thing well
    - **Comment quality**: Comments explain WHY, not WHAT (code should be self-documenting)
    - **Consistency**: Uniform style throughout the codebase

    ### 2. Design Principles
    - **SOLID principles**: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion
    - **DRY (Don't Repeat Yourself)**: No code duplication - extract shared logic
    - **KISS (Keep It Simple)**: Simplest solution that works
    - **YAGNI (You Aren't Gonna Need It)**: Don't add functionality until needed
    - **Separation of Concerns**: Clear boundaries between different aspects of functionality

    ### 3. Error Handling
    - **Graceful degradation**: Handle errors without crashing
    - **Specific exceptions**: Catch specific errors, not generic Exception
    - **Error context**: Provide meaningful error messages with context
    - **Resource cleanup**: Ensure resources are properly released (files, connections)
    - **No silent failures**: Log errors appropriately

    ### 4. Testing and Testability
    - **Unit test coverage**: Critical paths and edge cases covered
    - **Test clarity**: Tests are readable and clearly named
    - **Dependency injection**: Code structured for easy testing (IoC principles)
    - **Mock-friendly design**: External dependencies can be mocked
    - **Test independence**: Tests don't depend on each other

    ### 5. Performance Considerations
    - **Algorithmic efficiency**: Appropriate data structures and algorithms
    - **Resource usage**: Memory and CPU usage are reasonable
    - **Lazy loading**: Don't compute or load until needed
    - **Caching strategy**: Avoid redundant computations
    - **Database optimization**: Efficient queries, proper indexing

    ### 6. Security Best Practices
    - **Input validation**: All user input is validated and sanitized
    - **Authentication/Authorization**: Proper access controls in place
    - **Sensitive data**: Passwords, tokens, keys are never hardcoded
    - **SQL injection prevention**: Use parameterized queries
    - **XSS prevention**: Escape output, sanitize input
    - **Dependency scanning**: No known vulnerabilities in dependencies

    ### 7. Maintainability
    - **Modularity**: Code is broken into manageable, reusable modules
    - **Extensibility**: Easy to add new features without major refactoring
    - **Documentation**: Code is well-documented (inline and external)
    - **Version control**: Meaningful commit messages, logical commits
    - **Technical debt**: Minimize accumulation, track and address

    ### 8. Language-Specific Best Practices
    - **TypeScript/JavaScript**:
      - Strict mode enabled
      - Type safety (TypeScript types, not `any`)
      - Modern syntax (async/await, destructuring, etc.)
      - Proper module imports/exports

    - **Python**:
      - PEP 8 compliance
      - Type hints (PEP 484)
      - Proper exception handling
      - Context managers for resources

    - **Go**:
      - Error handling via return values
      - Proper goroutine management
      - Interface-based design
      - Idiomatic Go patterns

    ## Quality Scoring Rubric

    **Excellent (90-100)**: Production-ready, well-tested, follows all best practices
    **Good (75-89)**: Solid code with minor improvements needed
    **Acceptable (60-74)**: Functional but needs refactoring for maintainability
    **Needs Work (40-59)**: Significant issues affecting reliability or maintainability
    **Poor (0-39)**: Major issues requiring substantial rework

  validation: |
    - Code adheres to language-specific style guides
    - No obvious security vulnerabilities
    - Error handling is comprehensive
    - Code is testable and has appropriate test coverage
    - Performance is acceptable for intended use case

  example: |
    ## Example Quality Issues

    **Bad - Generic naming**:
    ```javascript
    function process(data) { ... }  // ❌ Too generic
    ```

    **Good - Descriptive naming**:
    ```javascript
    function validateUserCredentials(loginData) { ... }  // ✅ Clear purpose
    ```

    **Bad - No error handling**:
    ```python
    result = risky_operation()  # ❌ May crash
    ```

    **Good - Proper error handling**:
    ```python
    try:
        result = risky_operation()
    except SpecificError as e:
        logger.error(f"Operation failed: {e}")
        return fallback_value
    ```
